
<html>
<head>
<title>library/kani/src/lib.rs</title>
<link rel="stylesheet" type="text/css" href="../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 // Copyright Kani Contributors</div><div id="2" class="line none">    2 // SPDX-License-Identifier: Apache-2.0 OR MIT</div><div id="3" class="line none">    3 </div><div id="4" class="line none">    4 // Required so we can use kani_macros attributes.</div><div id="5" class="line none">    5 #![feature(register_tool)]</div><div id="6" class="line none">    6 #![register_tool(kanitool)]</div><div id="7" class="line none">    7 // Used for rustc_diagnostic_item.</div><div id="8" class="line none">    8 #![feature(rustc_attrs)]</div><div id="9" class="line none">    9 // This is required for the optimized version of `any_array()`</div><div id="10" class="line none">   10 #![feature(generic_const_exprs)]</div><div id="11" class="line none">   11 #![allow(incomplete_features)]</div><div id="12" class="line none">   12 </div><div id="13" class="line none">   13 pub mod <a href="lib.rs.html#13">arbitrary</a>;</div><div id="14" class="line none">   14 #[cfg(feature = "concrete_playback")]</div><div id="15" class="line none">   15 mod <a href="lib.rs.html#15">concrete_playback</a>;</div><div id="16" class="line none">   16 pub mod <a href="lib.rs.html#16">futures</a>;</div><div id="17" class="line none">   17 pub mod <a href="lib.rs.html#17">slice</a>;</div><div id="18" class="line none">   18 pub mod <a href="lib.rs.html#18">tuple</a>;</div><div id="19" class="line none">   19 pub mod <a href="lib.rs.html#19">vec</a>;</div><div id="20" class="line none">   20 </div><div id="21" class="line none">   21 pub use <a href="lib.rs.html#13">arbitrary</a>::Arbitrary;</div><div id="22" class="line none">   22 #[cfg(feature = "concrete_playback")]</div><div id="23" class="line none">   23 pub use <a href="lib.rs.html#15">concrete_playback</a>::<a href="lib.rs.html#26">concrete_playback_run</a>;</div><div id="24" class="line none">   24 #[cfg(not(feature = "concrete_playback"))]</div><div id="25" class="line none">   25 /// NOP `concrete_playback` for type checking during verification mode.</div><div id="26" class="line none">   26 pub fn <a href="lib.rs.html#26">concrete_playback_run</a>&lt;F: Fn()&gt;(_: Vec&lt;Vec&lt;u8&gt;&gt;, _: F) {</div><div id="27" class="line none">   27     <a href="../../std/src/lib.rs.html#145">unreachable</a>!("Concrete playback does not work during verification")</div><div id="28" class="line none">   28 }</div><div id="29" class="line none">   29 </div><div id="30" class="line none">   30 pub use <a href="lib.rs.html#16">futures</a>::block_on;</div><div id="31" class="line none">   31 </div><div id="32" class="line none">   32 /// Creates an assumption that will be valid after this statement run. Note that the assumption</div><div id="33" class="line none">   33 /// will only be applied for paths that follow the assumption. If the assumption doesn't hold, the</div><div id="34" class="line none">   34 /// program will exit successfully.</div><div id="35" class="line none">   35 ///</div><div id="36" class="line none">   36 /// # Example:</div><div id="37" class="line none">   37 ///</div><div id="38" class="line none">   38 /// The code snippet below should never panic.</div><div id="39" class="line none">   39 ///</div><div id="40" class="line none">   40 /// ```rust</div><div id="41" class="line none">   41 /// let i : i32 = kani::any();</div><div id="42" class="line none">   42 /// kani::assume(i &gt; 10);</div><div id="43" class="line none">   43 /// if i &lt; 0 {</div><div id="44" class="line none">   44 ///   panic!("This will never panic");</div><div id="45" class="line none">   45 /// }</div><div id="46" class="line none">   46 /// ```</div><div id="47" class="line none">   47 ///</div><div id="48" class="line none">   48 /// The following code may panic though:</div><div id="49" class="line none">   49 ///</div><div id="50" class="line none">   50 /// ```rust</div><div id="51" class="line none">   51 /// let i : i32 = kani::any();</div><div id="52" class="line none">   52 /// assert!(i &lt; 0, "This may panic and verification should fail.");</div><div id="53" class="line none">   53 /// kani::assume(i &gt; 10);</div><div id="54" class="line none">   54 /// ```</div><div id="55" class="line none">   55 #[inline(never)]</div><div id="56" class="line none">   56 #[rustc_diagnostic_item = "KaniAssume"]</div><div id="57" class="line none">   57 #[cfg(not(feature = "concrete_playback"))]</div><div id="58" class="line none">   58 pub fn <a href="lib.rs.html#58">assume</a>(cond: <a href="../kani_lib.c.html#12">bool</a>) {</div><div id="59" class="line none">   59     let _ = cond;</div><div id="60" class="line none">   60 }</div><div id="61" class="line none">   61 </div><div id="62" class="line none">   62 #[inline(never)]</div><div id="63" class="line none">   63 #[rustc_diagnostic_item = "KaniAssume"]</div><div id="64" class="line none">   64 #[cfg(feature = "concrete_playback")]</div><div id="65" class="line none">   65 pub fn <a href="lib.rs.html#58">assume</a>(cond: <a href="../kani_lib.c.html#12">bool</a>) {</div><div id="66" class="line none">   66     <a href="lib.rs.html#81">assert</a>!(cond, "`kani::assume` should always hold");</div><div id="67" class="line none">   67 }</div><div id="68" class="line none">   68 </div><div id="69" class="line none">   69 /// Creates an assertion of the specified condition and message.</div><div id="70" class="line none">   70 ///</div><div id="71" class="line none">   71 /// # Example:</div><div id="72" class="line none">   72 ///</div><div id="73" class="line none">   73 /// ```rust</div><div id="74" class="line none">   74 /// let x: bool = kani::any();</div><div id="75" class="line none">   75 /// let y = !x;</div><div id="76" class="line none">   76 /// kani::assert(x || y, "ORing a boolean variable with its negation must be true")</div><div id="77" class="line none">   77 /// ```</div><div id="78" class="line none">   78 #[cfg(not(feature = "concrete_playback"))]</div><div id="79" class="line none">   79 #[inline(never)]</div><div id="80" class="line none">   80 #[rustc_diagnostic_item = "KaniAssert"]</div><div id="81" class="line none">   81 pub const fn <a href="lib.rs.html#81">assert</a>(cond: <a href="../kani_lib.c.html#12">bool</a>, msg: &amp;'static str) {</div><div id="82" class="line none">   82     let _ = cond;</div><div id="83" class="line none">   83     let _ = msg;</div><div id="84" class="line none">   84 }</div><div id="85" class="line none">   85 </div><div id="86" class="line none">   86 #[cfg(feature = "concrete_playback")]</div><div id="87" class="line none">   87 #[inline(never)]</div><div id="88" class="line none">   88 #[rustc_diagnostic_item = "KaniAssert"]</div><div id="89" class="line none">   89 pub const fn <a href="lib.rs.html#81">assert</a>(cond: <a href="../kani_lib.c.html#12">bool</a>, msg: &amp;'static str) {</div><div id="90" class="line none">   90     <a href="lib.rs.html#81">assert</a>!(cond, "{}", msg);</div><div id="91" class="line none">   91 }</div><div id="92" class="line none">   92 </div><div id="93" class="line none">   93 /// Creates a cover property with the specified condition and message.</div><div id="94" class="line none">   94 ///</div><div id="95" class="line none">   95 /// # Example:</div><div id="96" class="line none">   96 ///</div><div id="97" class="line none">   97 /// ```rust</div><div id="98" class="line none">   98 /// kani::cover(slice.len() == 0, "The slice may have a length of 0");</div><div id="99" class="line none">   99 /// ```</div><div id="100" class="line none">  100 ///</div><div id="101" class="line none">  101 /// A cover property checks if there is at least one execution that satisfies</div><div id="102" class="line none">  102 /// the specified condition at the location in which the function is called.</div><div id="103" class="line none">  103 ///</div><div id="104" class="line none">  104 /// Cover properties are reported as:</div><div id="105" class="line none">  105 ///  - SATISFIED: if Kani found an execution that satisfies the condition</div><div id="106" class="line none">  106 ///  - UNSATISFIABLE: if Kani proved that the condition cannot be satisfied</div><div id="107" class="line none">  107 ///  - UNREACHABLE: if Kani proved that the cover property itself is unreachable (i.e. it is vacuously UNSATISFIABLE)</div><div id="108" class="line none">  108 ///</div><div id="109" class="line none">  109 /// This function is called by the [`cover!`] macro. The macro is more</div><div id="110" class="line none">  110 /// convenient to use.</div><div id="111" class="line none">  111 ///</div><div id="112" class="line none">  112 #[inline(never)]</div><div id="113" class="line none">  113 #[rustc_diagnostic_item = "KaniCover"]</div><div id="114" class="line none">  114 pub fn <a href="lib.rs.html#114">cover</a>(_cond: <a href="../kani_lib.c.html#12">bool</a>, _msg: &amp;'static str) {}</div><div id="115" class="line none">  115 </div><div id="116" class="line none">  116 /// This creates an symbolic *valid* value of type `T`. You can assign the return value of this</div><div id="117" class="line none">  117 /// function to a variable that you want to make symbolic.</div><div id="118" class="line none">  118 ///</div><div id="119" class="line none">  119 /// # Example:</div><div id="120" class="line none">  120 ///</div><div id="121" class="line none">  121 /// In the snippet below, we are verifying the behavior of the function `fn_under_verification`</div><div id="122" class="line none">  122 /// under all possible `NonZeroU8` input values, i.e., all possible `u8` values except zero.</div><div id="123" class="line none">  123 ///</div><div id="124" class="line none">  124 /// ```rust</div><div id="125" class="line none">  125 /// let inputA = kani::any::&lt;std::num::NonZeroU8&gt;();</div><div id="126" class="line none">  126 /// fn_under_verification(inputA);</div><div id="127" class="line none">  127 /// ```</div><div id="128" class="line none">  128 ///</div><div id="129" class="line none">  129 /// Note: This is a safe construct and can only be used with types that implement the `Arbitrary`</div><div id="130" class="line none">  130 /// trait. The Arbitrary trait is used to build a symbolic value that represents all possible</div><div id="131" class="line none">  131 /// valid values for type `T`.</div><div id="132" class="line none">  132 #[inline(always)]</div><div id="133" class="line none">  133 pub fn <a href="lib.rs.html#133">any</a>&lt;T: Arbitrary&gt;() -&gt; T {</div><div id="134" class="line none">  134     T::<a href="lib.rs.html#133">any</a>()</div><div id="135" class="line none">  135 }</div><div id="136" class="line none">  136 </div><div id="137" class="line none">  137 /// This creates a symbolic *valid* value of type `T`.</div><div id="138" class="line none">  138 /// The value is constrained to be a value accepted by the predicate passed to the filter.</div><div id="139" class="line none">  139 /// You can assign the return value of this function to a variable that you want to make symbolic.</div><div id="140" class="line none">  140 ///</div><div id="141" class="line none">  141 /// # Example:</div><div id="142" class="line none">  142 ///</div><div id="143" class="line none">  143 /// In the snippet below, we are verifying the behavior of the function `fn_under_verification`</div><div id="144" class="line none">  144 /// under all possible `u8` input values between 0 and 12.</div><div id="145" class="line none">  145 ///</div><div id="146" class="line none">  146 /// ```rust</div><div id="147" class="line none">  147 /// let inputA: u8 = kani::any_where(|x| *x &lt; 12);</div><div id="148" class="line none">  148 /// fn_under_verification(inputA);</div><div id="149" class="line none">  149 /// ```</div><div id="150" class="line none">  150 ///</div><div id="151" class="line none">  151 /// Note: This is a safe construct and can only be used with types that implement the `Arbitrary`</div><div id="152" class="line none">  152 /// trait. The Arbitrary trait is used to build a symbolic value that represents all possible</div><div id="153" class="line none">  153 /// valid values for type `T`.</div><div id="154" class="line none">  154 #[inline(always)]</div><div id="155" class="line none">  155 pub fn <a href="lib.rs.html#155">any_where</a>&lt;T: Arbitrary, F: FnOnce(&amp;T) -&gt; <a href="../kani_lib.c.html#12">bool</a>&gt;(f: F) -&gt; T {</div><div id="156" class="line none">  156     let result = T::<a href="lib.rs.html#133">any</a>();</div><div id="157" class="line none">  157     <a href="lib.rs.html#58">assume</a>(f(&amp;result));</div><div id="158" class="line none">  158     result</div><div id="159" class="line none">  159 }</div><div id="160" class="line none">  160 </div><div id="161" class="line none">  161 /// This function creates a symbolic value of type `T`. This may result in an invalid value.</div><div id="162" class="line none">  162 ///</div><div id="163" class="line none">  163 /// # Safety</div><div id="164" class="line none">  164 ///</div><div id="165" class="line none">  165 /// This function is unsafe and it may represent invalid `T` values which can lead to many</div><div id="166" class="line none">  166 /// undesirable undefined behaviors. Because of that, this function can only be used</div><div id="167" class="line none">  167 /// internally when we can guarantee that the type T has no restriction regarding its bit level</div><div id="168" class="line none">  168 /// representation.</div><div id="169" class="line none">  169 ///</div><div id="170" class="line none">  170 /// This function is also used to find concrete values in the CBMC output trace</div><div id="171" class="line none">  171 /// and return those concrete values in concrete playback mode.</div><div id="172" class="line none">  172 ///</div><div id="173" class="line none">  173 /// Note that SIZE_T must be equal the size of type T in bytes.</div><div id="174" class="line none">  174 #[inline(never)]</div><div id="175" class="line none">  175 #[cfg(not(feature = "concrete_playback"))]</div><div id="176" class="line none">  176 pub(crate) unsafe fn <a href="lib.rs.html#176">any_raw_internal</a>&lt;T, const SIZE_T: usize&gt;() -&gt; T {</div><div id="177" class="line none">  177     <a href="lib.rs.html#190">any_raw_inner</a>::&lt;T&gt;()</div><div id="178" class="line none">  178 }</div><div id="179" class="line none">  179 </div><div id="180" class="line none">  180 #[inline(never)]</div><div id="181" class="line none">  181 #[cfg(feature = "concrete_playback")]</div><div id="182" class="line none">  182 pub(crate) unsafe fn <a href="lib.rs.html#176">any_raw_internal</a>&lt;T, const SIZE_T: usize&gt;() -&gt; T {</div><div id="183" class="line none">  183     <a href="lib.rs.html#15">concrete_playback</a>::<a href="lib.rs.html#176">any_raw_internal</a>::&lt;T, SIZE_T&gt;()</div><div id="184" class="line none">  184 }</div><div id="185" class="line none">  185 </div><div id="186" class="line none">  186 /// This low-level function returns nondet bytes of size T.</div><div id="187" class="line none">  187 #[rustc_diagnostic_item = "KaniAnyRaw"]</div><div id="188" class="line none">  188 #[inline(never)]</div><div id="189" class="line none">  189 #[allow(dead_code)]</div><div id="190" class="line none">  190 fn <a href="lib.rs.html#190">any_raw_inner</a>&lt;T&gt;() -&gt; T {</div><div id="191" class="line none">  191     // while we could use `unreachable!()` or `panic!()` as the body of this</div><div id="192" class="line none">  192     // function, both cause Kani to produce a warning on any program that uses</div><div id="193" class="line none">  193     // kani::any() (see https://github.com/model-checking/kani/issues/2010).</div><div id="194" class="line none">  194     // This function is handled via a hook anyway, so we just need to put a body</div><div id="195" class="line none">  195     // that rustc does not complain about. An infinite loop works out nicely.</div><div id="196" class="line none">  196     #[allow(clippy::empty_loop)]</div><div id="197" class="line none">  197     loop {}</div><div id="198" class="line none">  198 }</div><div id="199" class="line none">  199 </div><div id="200" class="line none">  200 /// Function used to generate panic with a static message as this is the only one currently</div><div id="201" class="line none">  201 /// supported by Kani display.</div><div id="202" class="line none">  202 ///</div><div id="203" class="line none">  203 /// During verification this will get replaced by `assert(false)`. For concrete executions, we just</div><div id="204" class="line none">  204 /// invoke the regular `std::panic!()` function. This function is used by our standard library</div><div id="205" class="line none">  205 /// overrides, but not the other way around.</div><div id="206" class="line none">  206 #[inline(never)]</div><div id="207" class="line none">  207 #[rustc_diagnostic_item = "KaniPanic"]</div><div id="208" class="line none">  208 #[doc(hidden)]</div><div id="209" class="line none">  209 pub const fn <a href="lib.rs.html#209">panic</a>(message: &amp;'static str) -&gt; ! {</div><div id="210" class="line none">  210     <a href="lib.rs.html#209">panic</a>!("{}", message)</div><div id="211" class="line none">  211 }</div><div id="212" class="line none">  212 </div><div id="213" class="line none">  213 /// A macro to check if a condition is satisfiable at a specific location in the</div><div id="214" class="line none">  214 /// code.</div><div id="215" class="line none">  215 ///</div><div id="216" class="line none">  216 /// # Example 1:</div><div id="217" class="line none">  217 ///</div><div id="218" class="line none">  218 /// ```rust</div><div id="219" class="line none">  219 /// let mut set: BTreeSet&lt;i32&gt; = BTreeSet::new();</div><div id="220" class="line none">  220 /// set.insert(kani::any());</div><div id="221" class="line none">  221 /// set.insert(kani::any());</div><div id="222" class="line none">  222 /// // check if the set can end up with a single element (if both elements</div><div id="223" class="line none">  223 /// // inserted were the same)</div><div id="224" class="line none">  224 /// kani::cover!(set.len() == 1);</div><div id="225" class="line none">  225 /// ```</div><div id="226" class="line none">  226 /// The macro can also be called without any arguments to check if a location is</div><div id="227" class="line none">  227 /// reachable.</div><div id="228" class="line none">  228 ///</div><div id="229" class="line none">  229 /// # Example 2:</div><div id="230" class="line none">  230 ///</div><div id="231" class="line none">  231 /// ```rust</div><div id="232" class="line none">  232 /// match e {</div><div id="233" class="line none">  233 ///     MyEnum::A =&gt; { /* .. */ }</div><div id="234" class="line none">  234 ///     MyEnum::B =&gt; {</div><div id="235" class="line none">  235 ///         // make sure the `MyEnum::B` variant is possible</div><div id="236" class="line none">  236 ///         kani::cover!();</div><div id="237" class="line none">  237 ///         // ..</div><div id="238" class="line none">  238 ///     }</div><div id="239" class="line none">  239 /// }</div><div id="240" class="line none">  240 /// ```</div><div id="241" class="line none">  241 ///</div><div id="242" class="line none">  242 /// A custom message can also be passed to the macro.</div><div id="243" class="line none">  243 ///</div><div id="244" class="line none">  244 /// # Example 3:</div><div id="245" class="line none">  245 ///</div><div id="246" class="line none">  246 /// ```rust</div><div id="247" class="line none">  247 /// kani::cover!(x &gt; y, "x can be greater than y")</div><div id="248" class="line none">  248 /// ```</div><div id="249" class="line none">  249 #[macro_export]</div><div id="250" class="line none">  250 macro_rules! <a href="lib.rs.html#114">cover</a> {</div><div id="251" class="line none">  251     () =&gt; {</div><div id="252" class="line none">  252         kani::<a href="lib.rs.html#114">cover</a>(true, "cover location");</div><div id="253" class="line none">  253     };</div><div id="254" class="line none">  254     ($cond:expr $(,)?) =&gt; {</div><div id="255" class="line none">  255         kani::<a href="lib.rs.html#114">cover</a>($cond, concat!("cover condition: ", stringify!($cond)));</div><div id="256" class="line none">  256     };</div><div id="257" class="line none">  257     ($cond:expr, $msg:literal) =&gt; {</div><div id="258" class="line none">  258         kani::<a href="lib.rs.html#114">cover</a>($cond, $msg);</div><div id="259" class="line none">  259     };</div><div id="260" class="line none">  260 }</div><div id="261" class="line none">  261 </div><div id="262" class="line none">  262 /// Kani proc macros must be in a separate crate</div><div id="263" class="line none">  263 pub use kani_macros::*;</div>
</div>
</body>
</html>
