
<html>
<head>
<title>library/std/src/lib.rs</title>
<link rel="stylesheet" type="text/css" href="../../../viewer.css">
</head>

<body>
<div class="code">
<div id="1" class="line none">    1 // Copyright Kani Contributors</div><div id="2" class="line none">    2 // SPDX-License-Identifier: Apache-2.0 OR MIT</div><div id="3" class="line none">    3 </div><div id="4" class="line none">    4 //! The purpose of this crate is to allow kani to selectively override</div><div id="5" class="line none">    5 //! definitions from the standard library.  Definitions provided below would</div><div id="6" class="line none">    6 //! override the standard library versions.</div><div id="7" class="line none">    7 </div><div id="8" class="line none">    8 // See discussion in</div><div id="9" class="line none">    9 // https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/.E2.9C.94.20Globally.20override.20an.20std.20macro/near/268873354</div><div id="10" class="line none">   10 // for more details.</div><div id="11" class="line none">   11 </div><div id="12" class="line none">   12 // re-export all std symbols</div><div id="13" class="line none">   13 pub use std::*;</div><div id="14" class="line none">   14 </div><div id="15" class="line none">   15 // Bind `core::assert` to a different name to avoid possible name conflicts if a</div><div id="16" class="line none">   16 // crate uses `extern crate std as core`. See</div><div id="17" class="line none">   17 // https://github.com/model-checking/kani/issues/1949</div><div id="18" class="line none">   18 #[allow(unused_imports)]</div><div id="19" class="line none">   19 use core::<a href="../../kani/src/lib.rs.html#81">assert</a> as __kani__workaround_core_assert;</div><div id="20" class="line none">   20 </div><div id="21" class="line none">   21 // Override process calls with stubs.</div><div id="22" class="line none">   22 pub mod <a href="lib.rs.html#22">process</a>;</div><div id="23" class="line none">   23 </div><div id="24" class="line none">   24 /// This assert macro calls kani's assert function passing it down the condition</div><div id="25" class="line none">   25 /// as well as a message that will be used when reporting the assertion result.</div><div id="26" class="line none">   26 ///</div><div id="27" class="line none">   27 /// For the first form that does not involve a message, the macro will generate the following message:</div><div id="28" class="line none">   28 /// assertion failed: cond</div><div id="29" class="line none">   29 /// where `cond` is the stringified condition. For example, for</div><div id="30" class="line none">   30 /// ```rust</div><div id="31" class="line none">   31 /// assert!(1 + 1 == 2);</div><div id="32" class="line none">   32 /// ```</div><div id="33" class="line none">   33 /// the message will be:</div><div id="34" class="line none">   34 /// assertion failed: 1 + 1 == 2</div><div id="35" class="line none">   35 ///</div><div id="36" class="line none">   36 /// For the second form that involves a custom message possibly with arguments,</div><div id="37" class="line none">   37 /// the macro will generate a message that is a concat of the custom message</div><div id="38" class="line none">   38 /// along with all the arguments. For example, for</div><div id="39" class="line none">   39 /// ```rust</div><div id="40" class="line none">   40 /// assert!(a + b == c, "The sum of {} and {} is {}", a, b, c);</div><div id="41" class="line none">   41 /// ```</div><div id="42" class="line none">   42 /// the assert message will be:</div><div id="43" class="line none">   43 /// "The sum of {} and {} is {}", a, b, c</div><div id="44" class="line none">   44 #[macro_export]</div><div id="45" class="line none">   45 macro_rules! <a href="../../kani/src/lib.rs.html#81">assert</a> {</div><div id="46" class="line none">   46     ($cond:expr $(,)?) =&gt; {</div><div id="47" class="line none">   47         // The double negation is to resolve https://github.com/model-checking/kani/issues/2108</div><div id="48" class="line none">   48         kani::<a href="../../kani/src/lib.rs.html#81">assert</a>(!!$cond, concat!("assertion failed: ", stringify!($cond)));</div><div id="49" class="line none">   49     };</div><div id="50" class="line none">   50     ($cond:expr, $($arg:tt)+) =&gt; {{</div><div id="51" class="line both">   51         kani::<a href="../../kani/src/lib.rs.html#81">assert</a>(!!$cond, concat!(stringify!($($arg)+)));</div><div id="52" class="line none">   52         // Process the arguments of the assert inside an unreachable block. This</div><div id="53" class="line none">   53         // is to make sure errors in the arguments (e.g. an unknown variable or</div><div id="54" class="line none">   54         // an argument that does not implement the Display or Debug traits) are</div><div id="55" class="line none">   55         // reported, without creating any overhead on verification performance</div><div id="56" class="line none">   56         // that may arise from processing strings involved in the arguments.</div><div id="57" class="line none">   57         // Note that this approach is only correct with the "abort" panic</div><div id="58" class="line none">   58         // strategy, but is unsound with the "unwind" panic strategy which</div><div id="59" class="line none">   59         // requires evaluating the arguments (because they might have side</div><div id="60" class="line none">   60         // effects). This is fine until we add support for the "unwind" panic</div><div id="61" class="line none">   61         // strategy, which is tracked in</div><div id="62" class="line none">   62         // https://github.com/model-checking/kani/issues/692</div><div id="63" class="line both">   63         if false {</div><div id="64" class="line both">   64             __kani__workaround_core_assert!(true, $($arg)+);</div><div id="65" class="line none">   65         }</div><div id="66" class="line none">   66     }};</div><div id="67" class="line none">   67 }</div><div id="68" class="line none">   68 </div><div id="69" class="line none">   69 // Override the assert_eq and assert_ne macros to</div><div id="70" class="line none">   70 // 1. Bypass the formatting-related code in the standard library implementation,</div><div id="71" class="line none">   71 //    which is not relevant for verification (see</div><div id="72" class="line none">   72 //    https://github.com/model-checking/kani/issues/14)</div><div id="73" class="line none">   73 // 2. Generate a suitable message for the assert of the form:</div><div id="74" class="line none">   74 //        assertion failed: $left == $right</div><div id="75" class="line none">   75 //    instead of the uninformative:</div><div id="76" class="line none">   76 //        a panicking function core::panicking::assert_failed is invoked</div><div id="77" class="line none">   77 //    (see https://github.com/model-checking/kani/issues/13)</div><div id="78" class="line none">   78 // 3. Call kani::assert so that any instrumentation that it does (e.g. injecting</div><div id="79" class="line none">   79 //    reachability checks) is done for assert_eq and assert_ne</div><div id="80" class="line none">   80 #[macro_export]</div><div id="81" class="line none">   81 macro_rules! <a href="lib.rs.html#81">assert_eq</a> {</div><div id="82" class="line none">   82     ($left:expr, $right:expr $(,)?) =&gt; ({</div><div id="83" class="line none">   83         // Add parentheses around the operands to avoid a "comparison operators</div><div id="84" class="line none">   84         // cannot be chained" error, but exclude the parentheses in the message</div><div id="85" class="line none">   85         kani::<a href="../../kani/src/lib.rs.html#81">assert</a>(($left) == ($right), concat!("assertion failed: ", stringify!($left == $right)));</div><div id="86" class="line none">   86     });</div><div id="87" class="line none">   87     ($left:expr, $right:expr, $($arg:tt)+) =&gt; ({</div><div id="88" class="line none">   88         <a href="../../kani/src/lib.rs.html#81">assert</a>!(($left) == ($right), $($arg)+);</div><div id="89" class="line none">   89     });</div><div id="90" class="line none">   90 }</div><div id="91" class="line none">   91 </div><div id="92" class="line none">   92 #[macro_export]</div><div id="93" class="line none">   93 macro_rules! <a href="lib.rs.html#93">assert_ne</a> {</div><div id="94" class="line none">   94     ($left:expr, $right:expr $(,)?) =&gt; ({</div><div id="95" class="line none">   95         // Add parentheses around the operands to avoid a "comparison operators</div><div id="96" class="line none">   96         // cannot be chained" error, but exclude the parentheses in the message</div><div id="97" class="line none">   97         kani::<a href="../../kani/src/lib.rs.html#81">assert</a>(($left) != ($right), concat!("assertion failed: ", stringify!($left != $right)));</div><div id="98" class="line none">   98     });</div><div id="99" class="line none">   99     ($left:expr, $right:expr, $($arg:tt)+) =&gt; ({</div><div id="100" class="line none">  100         <a href="../../kani/src/lib.rs.html#81">assert</a>!(($left) != ($right), $($arg)+);</div><div id="101" class="line none">  101     });</div><div id="102" class="line none">  102 }</div><div id="103" class="line none">  103 </div><div id="104" class="line none">  104 // Treat the debug assert macros same as non-debug ones</div><div id="105" class="line none">  105 #[macro_export]</div><div id="106" class="line none">  106 macro_rules! <a href="lib.rs.html#106">debug_assert</a> {</div><div id="107" class="line none">  107     ($($x:tt)*) =&gt; ({ $crate::<a href="../../kani/src/lib.rs.html#81">assert</a>!($($x)*); })</div><div id="108" class="line none">  108 }</div><div id="109" class="line none">  109 </div><div id="110" class="line none">  110 #[macro_export]</div><div id="111" class="line none">  111 macro_rules! <a href="lib.rs.html#111">debug_assert_eq</a> {</div><div id="112" class="line none">  112     ($($x:tt)*) =&gt; ({ $crate::<a href="lib.rs.html#81">assert_eq</a>!($($x)*); })</div><div id="113" class="line none">  113 }</div><div id="114" class="line none">  114 </div><div id="115" class="line none">  115 #[macro_export]</div><div id="116" class="line none">  116 macro_rules! <a href="lib.rs.html#116">debug_assert_ne</a> {</div><div id="117" class="line none">  117     ($($x:tt)*) =&gt; ({ $crate::<a href="lib.rs.html#93">assert_ne</a>!($($x)*); })</div><div id="118" class="line none">  118 }</div><div id="119" class="line none">  119 </div><div id="120" class="line none">  120 // Override the print macros to skip all the printing functionality (which</div><div id="121" class="line none">  121 // is not relevant for verification)</div><div id="122" class="line none">  122 #[macro_export]</div><div id="123" class="line none">  123 macro_rules! <a href="lib.rs.html#123">print</a> {</div><div id="124" class="line none">  124     ($($x:tt)*) =&gt; {{ let _ = format_args!($($x)*); }};</div><div id="125" class="line none">  125 }</div><div id="126" class="line none">  126 </div><div id="127" class="line none">  127 #[macro_export]</div><div id="128" class="line none">  128 macro_rules! <a href="lib.rs.html#128">eprint</a> {</div><div id="129" class="line none">  129     ($($x:tt)*) =&gt; {{ let _ = format_args!($($x)*); }};</div><div id="130" class="line none">  130 }</div><div id="131" class="line none">  131 </div><div id="132" class="line none">  132 #[macro_export]</div><div id="133" class="line none">  133 macro_rules! <a href="lib.rs.html#133">println</a> {</div><div id="134" class="line none">  134     () =&gt; { };</div><div id="135" class="line none">  135     ($($x:tt)*) =&gt; {{ let _ = format_args!($($x)*); }};</div><div id="136" class="line none">  136 }</div><div id="137" class="line none">  137 </div><div id="138" class="line none">  138 #[macro_export]</div><div id="139" class="line none">  139 macro_rules! <a href="lib.rs.html#139">eprintln</a> {</div><div id="140" class="line none">  140     () =&gt; { };</div><div id="141" class="line none">  141     ($($x:tt)*) =&gt; {{ let _ = format_args!($($x)*); }};</div><div id="142" class="line none">  142 }</div><div id="143" class="line none">  143 </div><div id="144" class="line none">  144 #[macro_export]</div><div id="145" class="line none">  145 macro_rules! <a href="lib.rs.html#145">unreachable</a> {</div><div id="146" class="line none">  146     // The argument, if present, is a literal that represents the error message, i.e.:</div><div id="147" class="line none">  147     // `unreachable!("Error message")` or `unreachable!()`</div><div id="148" class="line none">  148     ($($msg:literal)? $(,)?) =&gt; (</div><div id="149" class="line none">  149         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>(concat!("internal error: entered unreachable code: ", $($msg)?))</div><div id="150" class="line none">  150     );</div><div id="151" class="line none">  151     // The argument is an expression, such as a variable.</div><div id="152" class="line none">  152     // ```</div><div id="153" class="line none">  153     // let msg = format!("Error: {}", code);</div><div id="154" class="line none">  154     // unreachable!(msg);</div><div id="155" class="line none">  155     // ```</div><div id="156" class="line none">  156     // This was supported for 2018 and older rust editions.</div><div id="157" class="line none">  157     // TODO: Is it possible to trigger an error if 2021 and above?</div><div id="158" class="line none">  158     // https://github.com/model-checking/kani/issues/1375</div><div id="159" class="line none">  159     ($($msg:expr)? $(,)?) =&gt; (</div><div id="160" class="line none">  160         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>(concat!("internal error: entered unreachable code: ", stringify!($($msg)?)))</div><div id="161" class="line none">  161     );</div><div id="162" class="line none">  162     // The first argument is the format and the rest contains tokens to be included in the msg.</div><div id="163" class="line none">  163     // `unreachable!("Error: {}", code);`</div><div id="164" class="line none">  164     // We have the same issue as with panic!() described bellow where we over-approx what we can</div><div id="165" class="line none">  165     // handle.</div><div id="166" class="line none">  166     ($fmt:expr, $($arg:tt)*) =&gt; {{</div><div id="167" class="line none">  167         if false {</div><div id="168" class="line none">  168             __kani__workaround_core_assert!(true, $fmt, $($arg)+);</div><div id="169" class="line none">  169         }</div><div id="170" class="line none">  170         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>(concat!("internal error: entered unreachable code: ",</div><div id="171" class="line none">  171         stringify!($fmt, $($arg)*)))}};</div><div id="172" class="line none">  172 }</div><div id="173" class="line none">  173 </div><div id="174" class="line none">  174 #[macro_export]</div><div id="175" class="line none">  175 macro_rules! <a href="../../kani/src/lib.rs.html#209">panic</a> {</div><div id="176" class="line none">  176     // No argument is given.</div><div id="177" class="line none">  177     () =&gt; (</div><div id="178" class="line none">  178         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>("explicit panic")</div><div id="179" class="line none">  179     );</div><div id="180" class="line none">  180     // The argument is a literal that represents the error message, i.e.:</div><div id="181" class="line none">  181     // `panic!("Error message")`</div><div id="182" class="line none">  182     ($msg:literal $(,)?) =&gt; ({</div><div id="183" class="line none">  183         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>(concat!($msg));</div><div id="184" class="line none">  184     });</div><div id="185" class="line none">  185     // The argument is an expression, such as a variable.</div><div id="186" class="line none">  186     // ```</div><div id="187" class="line none">  187     // let msg = format!("Error: {}", code);</div><div id="188" class="line none">  188     // panic!(msg);</div><div id="189" class="line none">  189     // ```</div><div id="190" class="line none">  190     // This was supported for 2018 and older rust editions.</div><div id="191" class="line none">  191     // TODO: Is it possible to trigger an error if 2021 and above?</div><div id="192" class="line none">  192     // https://github.com/model-checking/kani/issues/1375</div><div id="193" class="line none">  193     ($msg:expr $(,)?) =&gt; ({</div><div id="194" class="line none">  194         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>(stringify!($msg));</div><div id="195" class="line none">  195     });</div><div id="196" class="line none">  196     // All other cases, e.g.:</div><div id="197" class="line none">  197     // `panic!("Error: {}", code);`</div><div id="198" class="line none">  198     ($($arg:tt)+) =&gt; {{</div><div id="199" class="line none">  199         if false {</div><div id="200" class="line none">  200             __kani__workaround_core_assert!(true, $($arg)+);</div><div id="201" class="line none">  201         }</div><div id="202" class="line none">  202         kani::<a href="../../kani/src/lib.rs.html#209">panic</a>(stringify!($($arg)+));</div><div id="203" class="line none">  203     }};</div><div id="204" class="line none">  204 }</div>
</div>
</body>
</html>
